// Copyright 2025 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either expresso or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated Code - DO NOT EDIT !!
// generated by 'emugen'
#include "renderControl_dec.h"

#include <cstring>
#include <stdio.h>
#include <string.h>

#include "renderControl_opcodes.h"
#include "gfxstream/common/logging.h"
#include "gfxstream/host/ChecksumCalculatorThreadInfo.h"
#include "gfxstream/host/ProtocolUtils.h"
namespace gfxstream {
typedef unsigned int tsize_t; // Target "size_t", which is 32-bit for now. It may or may not be the same as host's size_t when emugen is compiled.

#ifdef CHECK_GL_ERRORS
#  define SET_LASTCALL(name)  sprintf(lastCall, #name)
#else
#  define SET_LASTCALL(name)
#endif
size_t renderControl_decoder_context_t::decode(void *buf, size_t len, IOStream *stream, ChecksumCalculator* checksumCalc) {
	if (len < 8) return 0;
#ifdef CHECK_GL_ERRORS
	char lastCall[256] = {0};
#endif
	unsigned char *ptr = (unsigned char *)buf;
	const unsigned char* const end = (const unsigned char*)buf + len;
	while (end - ptr >= 8) {
		uint32_t opcode = *(uint32_t *)ptr;
		uint32_t packetLen = *(uint32_t *)(ptr + 4);
		if (end - ptr < packetLen) return ptr - (unsigned char*)buf;
        // Do this on every iteration, as some commands may change the checksum
        // calculation parameters.
        const size_t checksumSize = checksumCalc->checksumByteSize();
        const bool useChecksum = checksumSize > 0;
		switch(opcode) {
		case OP_rcGetRendererVersion: {
			gfxstream::base::beginTrace("rcGetRendererVersion decode");
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetRendererVersion: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetRendererVersion()", stream);
			GLint function_call_retval = 			this->rcGetRendererVersion();
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(GLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetRendererVersion");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetEGLVersion: {
			gfxstream::base::beginTrace("rcGetEGLVersion decode");
			uint32_t size_major __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_minor __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetEGLVersion: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_major;
			totalTmpSize += size_minor;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_major(&tmpBuf[0], size_major);
			OutputBuffer outptr_minor(&tmpBuf[0 + size_major], size_minor);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetEGLVersion(major:%p(%u) minor:%p(%u) )", stream, (EGLint*)(outptr_major.get()), size_major, (EGLint*)(outptr_minor.get()), size_minor);
			EGLint function_call_retval = 			this->rcGetEGLVersion((EGLint*)(outptr_major.get()), (EGLint*)(outptr_minor.get()));
			std::memcpy(&tmpBuf[0 + size_major + size_minor], &function_call_retval, sizeof(EGLint));
			outptr_major.flush();
			outptr_minor.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetEGLVersion");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcQueryEGLString: {
			gfxstream::base::beginTrace("rcQueryEGLString decode");
			EGLenum var_name = Unpack<EGLenum,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			EGLint var_bufferSize = Unpack<EGLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcQueryEGLString: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DECODER_DEBUG_LOG("renderControl(%p): rcQueryEGLString(name:0x%08x buffer:%p(%u) bufferSize:0x%08x )", stream, var_name, (void*)(outptr_buffer.get()), size_buffer, var_bufferSize);
			EGLint function_call_retval = 			this->rcQueryEGLString(var_name, (void*)(outptr_buffer.get()), var_bufferSize);
			std::memcpy(&tmpBuf[0 + size_buffer], &function_call_retval, sizeof(EGLint));
			outptr_buffer.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcQueryEGLString");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetGLString: {
			gfxstream::base::beginTrace("rcGetGLString decode");
			EGLenum var_name = Unpack<EGLenum,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			EGLint var_bufferSize = Unpack<EGLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetGLString: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetGLString(name:0x%08x buffer:%p(%u) bufferSize:0x%08x )", stream, var_name, (void*)(outptr_buffer.get()), size_buffer, var_bufferSize);
			EGLint function_call_retval = 			this->rcGetGLString(var_name, (void*)(outptr_buffer.get()), var_bufferSize);
			std::memcpy(&tmpBuf[0 + size_buffer], &function_call_retval, sizeof(EGLint));
			outptr_buffer.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetGLString");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetNumConfigs: {
			gfxstream::base::beginTrace("rcGetNumConfigs decode");
			uint32_t size_numAttribs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetNumConfigs: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_numAttribs;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_numAttribs(&tmpBuf[0], size_numAttribs);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetNumConfigs(numAttribs:%p(%u) )", stream, (uint32_t*)(outptr_numAttribs.get()), size_numAttribs);
			EGLint function_call_retval = 			this->rcGetNumConfigs((uint32_t*)(outptr_numAttribs.get()));
			std::memcpy(&tmpBuf[0 + size_numAttribs], &function_call_retval, sizeof(EGLint));
			outptr_numAttribs.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetNumConfigs");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetConfigs: {
			gfxstream::base::beginTrace("rcGetConfigs decode");
			uint32_t var_bufSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetConfigs: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetConfigs(bufSize:0x%08x buffer:%p(%u) )", stream, var_bufSize, (GLuint*)(outptr_buffer.get()), size_buffer);
			EGLint function_call_retval = 			this->rcGetConfigs(var_bufSize, (GLuint*)(outptr_buffer.get()));
			std::memcpy(&tmpBuf[0 + size_buffer], &function_call_retval, sizeof(EGLint));
			outptr_buffer.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetConfigs");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcChooseConfig: {
			gfxstream::base::beginTrace("rcChooseConfig decode");
			uint32_t size_attribs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_attribs(ptr + 8 + 4, size_attribs);
			uint32_t var_attribs_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs);
			uint32_t size_configs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs + 4);
			uint32_t var_configs_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_attribs + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_attribs + 4 + 4 + 4, ptr + 8 + 4 + size_attribs + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcChooseConfig: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_configs;
			totalTmpSize += sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_configs(&tmpBuf[0], size_configs);
			DECODER_DEBUG_LOG("renderControl(%p): rcChooseConfig(attribs:%p(%u) attribs_size:0x%08x configs:%p(%u) configs_size:0x%08x )", stream, (EGLint*)(inptr_attribs.get()), size_attribs, var_attribs_size, (uint32_t*)(outptr_configs.get()), size_configs, var_configs_size);
			EGLint function_call_retval = 			this->rcChooseConfig((EGLint*)(inptr_attribs.get()), var_attribs_size, size_configs == 0 ? nullptr : (uint32_t*)(outptr_configs.get()), var_configs_size);
			std::memcpy(&tmpBuf[0 + size_configs], &function_call_retval, sizeof(EGLint));
			outptr_configs.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcChooseConfig");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetFBParam: {
			gfxstream::base::beginTrace("rcGetFBParam decode");
			EGLint var_param = Unpack<EGLint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetFBParam: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetFBParam(param:0x%08x )", stream, var_param);
			EGLint function_call_retval = 			this->rcGetFBParam(var_param);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(EGLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetFBParam");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateContext: {
			gfxstream::base::beginTrace("rcCreateContext decode");
			uint32_t var_config = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_share = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_glVersion = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateContext: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateContext(config:0x%08x share:0x%08x glVersion:0x%08x )", stream, var_config, var_share, var_glVersion);
			uint32_t function_call_retval = 			this->rcCreateContext(var_config, var_share, var_glVersion);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateContext");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroyContext: {
			gfxstream::base::beginTrace("rcDestroyContext decode");
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroyContext: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroyContext(context:0x%08x )", stream, var_context);
			this->rcDestroyContext(var_context);
			SET_LASTCALL("rcDestroyContext");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateWindowSurface: {
			gfxstream::base::beginTrace("rcCreateWindowSurface decode");
			uint32_t var_config = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateWindowSurface: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateWindowSurface(config:0x%08x width:0x%08x height:0x%08x )", stream, var_config, var_width, var_height);
			uint32_t function_call_retval = 			this->rcCreateWindowSurface(var_config, var_width, var_height);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateWindowSurface");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroyWindowSurface: {
			gfxstream::base::beginTrace("rcDestroyWindowSurface decode");
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroyWindowSurface: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroyWindowSurface(windowSurface:0x%08x )", stream, var_windowSurface);
			this->rcDestroyWindowSurface(var_windowSurface);
			SET_LASTCALL("rcDestroyWindowSurface");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateColorBuffer: {
			gfxstream::base::beginTrace("rcCreateColorBuffer decode");
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			GLenum var_internalFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateColorBuffer(width:0x%08x height:0x%08x internalFormat:0x%08x )", stream, var_width, var_height, var_internalFormat);
			uint32_t function_call_retval = 			this->rcCreateColorBuffer(var_width, var_height, var_internalFormat);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcOpenColorBuffer: {
			gfxstream::base::beginTrace("rcOpenColorBuffer decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcOpenColorBuffer: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcOpenColorBuffer(colorbuffer:0x%08x )", stream, var_colorbuffer);
			this->rcOpenColorBuffer(var_colorbuffer);
			SET_LASTCALL("rcOpenColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCloseColorBuffer: {
			gfxstream::base::beginTrace("rcCloseColorBuffer decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCloseColorBuffer: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcCloseColorBuffer(colorbuffer:0x%08x )", stream, var_colorbuffer);
			this->rcCloseColorBuffer(var_colorbuffer);
			SET_LASTCALL("rcCloseColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetWindowColorBuffer: {
			gfxstream::base::beginTrace("rcSetWindowColorBuffer decode");
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetWindowColorBuffer: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcSetWindowColorBuffer(windowSurface:0x%08x colorBuffer:0x%08x )", stream, var_windowSurface, var_colorBuffer);
			this->rcSetWindowColorBuffer(var_windowSurface, var_colorBuffer);
			SET_LASTCALL("rcSetWindowColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcFlushWindowColorBuffer: {
			gfxstream::base::beginTrace("rcFlushWindowColorBuffer decode");
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcFlushWindowColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcFlushWindowColorBuffer(windowSurface:0x%08x )", stream, var_windowSurface);
			int function_call_retval = 			this->rcFlushWindowColorBuffer(var_windowSurface);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcFlushWindowColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcMakeCurrent: {
			gfxstream::base::beginTrace("rcMakeCurrent decode");
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_drawSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_readSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcMakeCurrent: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcMakeCurrent(context:0x%08x drawSurf:0x%08x readSurf:0x%08x )", stream, var_context, var_drawSurf, var_readSurf);
			EGLint function_call_retval = 			this->rcMakeCurrent(var_context, var_drawSurf, var_readSurf);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(EGLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcMakeCurrent");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcFBPost: {
			gfxstream::base::beginTrace("rcFBPost decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcFBPost: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcFBPost(colorBuffer:0x%08x )", stream, var_colorBuffer);
			this->rcFBPost(var_colorBuffer);
			SET_LASTCALL("rcFBPost");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcFBSetSwapInterval: {
			gfxstream::base::beginTrace("rcFBSetSwapInterval decode");
			EGLint var_interval = Unpack<EGLint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcFBSetSwapInterval: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcFBSetSwapInterval(interval:0x%08x )", stream, var_interval);
			this->rcFBSetSwapInterval(var_interval);
			SET_LASTCALL("rcFBSetSwapInterval");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcBindTexture: {
			gfxstream::base::beginTrace("rcBindTexture decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcBindTexture: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcBindTexture(colorBuffer:0x%08x )", stream, var_colorBuffer);
			this->rcBindTexture(var_colorBuffer);
			SET_LASTCALL("rcBindTexture");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcBindRenderbuffer: {
			gfxstream::base::beginTrace("rcBindRenderbuffer decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcBindRenderbuffer: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcBindRenderbuffer(colorBuffer:0x%08x )", stream, var_colorBuffer);
			this->rcBindRenderbuffer(var_colorBuffer);
			SET_LASTCALL("rcBindRenderbuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcColorBufferCacheFlush: {
			gfxstream::base::beginTrace("rcColorBufferCacheFlush decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			EGLint var_postCount = Unpack<EGLint,uint32_t>(ptr + 8 + 4);
			int var_forRead = Unpack<int,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcColorBufferCacheFlush: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcColorBufferCacheFlush(colorbuffer:0x%08x postCount:0x%08x forRead:%d )", stream, var_colorbuffer, var_postCount, var_forRead);
			EGLint function_call_retval = 			this->rcColorBufferCacheFlush(var_colorbuffer, var_postCount, var_forRead);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(EGLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcColorBufferCacheFlush");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcReadColorBuffer: {
			gfxstream::base::beginTrace("rcReadColorBuffer decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcReadColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_pixels;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pixels(&tmpBuf[0], size_pixels);
			DECODER_DEBUG_LOG("renderControl(%p): rcReadColorBuffer(colorbuffer:0x%08x x:0x%08x y:0x%08x width:0x%08x height:0x%08x format:0x%08x type:0x%08x pixels:%p(%u) )", stream, var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(outptr_pixels.get()), size_pixels);
			this->rcReadColorBuffer(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(outptr_pixels.get()));
			outptr_pixels.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcReadColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcUpdateColorBuffer: {
			gfxstream::base::beginTrace("rcUpdateColorBuffer decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcUpdateColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcUpdateColorBuffer(colorbuffer:0x%08x x:0x%08x y:0x%08x width:0x%08x height:0x%08x format:0x%08x type:0x%08x pixels:%p(%u) )", stream, var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(inptr_pixels.get()), size_pixels);
			int function_call_retval = 			this->rcUpdateColorBuffer(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, (void*)(inptr_pixels.get()));
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcUpdateColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcOpenColorBuffer2: {
			gfxstream::base::beginTrace("rcOpenColorBuffer2 decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcOpenColorBuffer2: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcOpenColorBuffer2(colorbuffer:0x%08x )", stream, var_colorbuffer);
			int function_call_retval = 			this->rcOpenColorBuffer2(var_colorbuffer);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcOpenColorBuffer2");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateClientImage: {
			gfxstream::base::beginTrace("rcCreateClientImage decode");
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			EGLenum var_target = Unpack<EGLenum,uint32_t>(ptr + 8 + 4);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateClientImage: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateClientImage(context:0x%08x target:0x%08x buffer:0x%08x )", stream, var_context, var_target, var_buffer);
			uint32_t function_call_retval = 			this->rcCreateClientImage(var_context, var_target, var_buffer);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateClientImage");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroyClientImage: {
			gfxstream::base::beginTrace("rcDestroyClientImage decode");
			uint32_t var_image = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroyClientImage: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroyClientImage(image:0x%08x )", stream, var_image);
			int function_call_retval = 			this->rcDestroyClientImage(var_image);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcDestroyClientImage");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSelectChecksumHelper: {
			gfxstream::base::beginTrace("rcSelectChecksumHelper decode");
			uint32_t var_newProtocol = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_reserved = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSelectChecksumHelper: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcSelectChecksumHelper(newProtocol:0x%08x reserved:0x%08x )", stream, var_newProtocol, var_reserved);
			this->rcSelectChecksumHelper(var_newProtocol, var_reserved);
			SET_LASTCALL("rcSelectChecksumHelper");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateSyncKHR: {
			gfxstream::base::beginTrace("rcCreateSyncKHR decode");
			EGLenum var_type = Unpack<EGLenum,uint32_t>(ptr + 8);
			uint32_t size_attribs __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_attribs(ptr + 8 + 4 + 4, size_attribs);
			uint32_t var_num_attribs = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_attribs);
			int var_destroy_when_signaled = Unpack<int,uint32_t>(ptr + 8 + 4 + 4 + size_attribs + 4);
			uint32_t size_glsync_out __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_attribs + 4 + 4);
			uint32_t size_syncthread_out __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_attribs + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_attribs + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + size_attribs + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateSyncKHR: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_glsync_out;
			totalTmpSize += size_syncthread_out;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_glsync_out(&tmpBuf[0], size_glsync_out);
			OutputBuffer outptr_syncthread_out(&tmpBuf[0 + size_glsync_out], size_syncthread_out);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateSyncKHR(type:0x%08x attribs:%p(%u) num_attribs:0x%08x destroy_when_signaled:%d glsync_out:%p(%u) syncthread_out:%p(%u) )", stream, var_type, (EGLint*)(inptr_attribs.get()), size_attribs, var_num_attribs, var_destroy_when_signaled, (uint64_t*)(outptr_glsync_out.get()), size_glsync_out, (uint64_t*)(outptr_syncthread_out.get()), size_syncthread_out);
			this->rcCreateSyncKHR(var_type, (EGLint*)(inptr_attribs.get()), var_num_attribs, var_destroy_when_signaled, (uint64_t*)(outptr_glsync_out.get()), (uint64_t*)(outptr_syncthread_out.get()));
			outptr_glsync_out.flush();
			outptr_syncthread_out.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateSyncKHR");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcClientWaitSyncKHR: {
			gfxstream::base::beginTrace("rcClientWaitSyncKHR decode");
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			EGLint var_flags = Unpack<EGLint,uint32_t>(ptr + 8 + 8);
			uint64_t var_timeout = Unpack<uint64_t,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcClientWaitSyncKHR: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(EGLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcClientWaitSyncKHR(sync:0x%016lx flags:0x%08x timeout:0x%016lx )", stream, var_sync, var_flags, var_timeout);
			EGLint function_call_retval = 			this->rcClientWaitSyncKHR(var_sync, var_flags, var_timeout);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(EGLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcClientWaitSyncKHR");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcFlushWindowColorBufferAsync: {
			gfxstream::base::beginTrace("rcFlushWindowColorBufferAsync decode");
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcFlushWindowColorBufferAsync: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcFlushWindowColorBufferAsync(windowSurface:0x%08x )", stream, var_windowSurface);
			this->rcFlushWindowColorBufferAsync(var_windowSurface);
			SET_LASTCALL("rcFlushWindowColorBufferAsync");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroySyncKHR: {
			gfxstream::base::beginTrace("rcDestroySyncKHR decode");
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroySyncKHR: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroySyncKHR(sync:0x%016lx )", stream, var_sync);
			int function_call_retval = 			this->rcDestroySyncKHR(var_sync);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcDestroySyncKHR");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetPuid: {
			gfxstream::base::beginTrace("rcSetPuid decode");
			uint64_t var_puid = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetPuid: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcSetPuid(puid:0x%016lx )", stream, var_puid);
			this->rcSetPuid(var_puid);
			SET_LASTCALL("rcSetPuid");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcUpdateColorBufferDMA: {
			gfxstream::base::beginTrace("rcUpdateColorBufferDMA decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint64_t var_pixels_guest_paddr = Unpack<uint64_t,uint64_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			void* var_pixels = stream->getDmaForReading(var_pixels_guest_paddr);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8);
			uint32_t var_pixels_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcUpdateColorBufferDMA: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcUpdateColorBufferDMA(colorbuffer:0x%08x x:0x%08x y:0x%08x width:0x%08x height:0x%08x format:0x%08x type:0x%08x pixels:%p(%u) pixels_size:0x%08x )", stream, var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, var_pixels, var_pixels_size);
			int function_call_retval = 			this->rcUpdateColorBufferDMA(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, var_pixels, var_pixels_size);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			stream->unlockDma(var_pixels_guest_paddr);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcUpdateColorBufferDMA");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateColorBufferDMA: {
			gfxstream::base::beginTrace("rcCreateColorBufferDMA decode");
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			GLenum var_internalFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			int var_frameworkFormat = Unpack<int,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateColorBufferDMA: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateColorBufferDMA(width:0x%08x height:0x%08x internalFormat:0x%08x frameworkFormat:%d )", stream, var_width, var_height, var_internalFormat, var_frameworkFormat);
			uint32_t function_call_retval = 			this->rcCreateColorBufferDMA(var_width, var_height, var_internalFormat, var_frameworkFormat);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateColorBufferDMA");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcWaitSyncKHR: {
			gfxstream::base::beginTrace("rcWaitSyncKHR decode");
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			EGLint var_flags = Unpack<EGLint,uint32_t>(ptr + 8 + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4, ptr + 8 + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcWaitSyncKHR: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcWaitSyncKHR(sync:0x%016lx flags:0x%08x )", stream, var_sync, var_flags);
			this->rcWaitSyncKHR(var_sync, var_flags);
			SET_LASTCALL("rcWaitSyncKHR");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCompose: {
			gfxstream::base::beginTrace("rcCompose decode");
			uint32_t var_bufferSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffer(ptr + 8 + 4 + 4, size_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_buffer, ptr + 8 + 4 + 4 + size_buffer, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCompose: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCompose(bufferSize:0x%08x buffer:%p(%u) )", stream, var_bufferSize, (void*)(inptr_buffer.get()), size_buffer);
			GLint function_call_retval = 			this->rcCompose(var_bufferSize, (void*)(inptr_buffer.get()));
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(GLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCompose");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateDisplay: {
			gfxstream::base::beginTrace("rcCreateDisplay decode");
			uint32_t size_displayId __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateDisplay: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_displayId;
			totalTmpSize += sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_displayId(&tmpBuf[0], size_displayId);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateDisplay(displayId:%p(%u) )", stream, (uint32_t*)(outptr_displayId.get()), size_displayId);
			int function_call_retval = 			this->rcCreateDisplay((uint32_t*)(outptr_displayId.get()));
			std::memcpy(&tmpBuf[0 + size_displayId], &function_call_retval, sizeof(int));
			outptr_displayId.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateDisplay");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroyDisplay: {
			gfxstream::base::beginTrace("rcDestroyDisplay decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroyDisplay: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroyDisplay(displayId:0x%08x )", stream, var_displayId);
			int function_call_retval = 			this->rcDestroyDisplay(var_displayId);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcDestroyDisplay");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetDisplayColorBuffer: {
			gfxstream::base::beginTrace("rcSetDisplayColorBuffer decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetDisplayColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcSetDisplayColorBuffer(displayId:0x%08x colorBuffer:0x%08x )", stream, var_displayId, var_colorBuffer);
			int function_call_retval = 			this->rcSetDisplayColorBuffer(var_displayId, var_colorBuffer);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcSetDisplayColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetDisplayColorBuffer: {
			gfxstream::base::beginTrace("rcGetDisplayColorBuffer decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_colorBuffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetDisplayColorBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_colorBuffer;
			totalTmpSize += sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_colorBuffer(&tmpBuf[0], size_colorBuffer);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetDisplayColorBuffer(displayId:0x%08x colorBuffer:%p(%u) )", stream, var_displayId, (uint32_t*)(outptr_colorBuffer.get()), size_colorBuffer);
			int function_call_retval = 			this->rcGetDisplayColorBuffer(var_displayId, (uint32_t*)(outptr_colorBuffer.get()));
			std::memcpy(&tmpBuf[0 + size_colorBuffer], &function_call_retval, sizeof(int));
			outptr_colorBuffer.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetDisplayColorBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetColorBufferDisplay: {
			gfxstream::base::beginTrace("rcGetColorBufferDisplay decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_displayId __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetColorBufferDisplay: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_displayId;
			totalTmpSize += sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_displayId(&tmpBuf[0], size_displayId);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetColorBufferDisplay(colorBuffer:0x%08x displayId:%p(%u) )", stream, var_colorBuffer, (uint32_t*)(outptr_displayId.get()), size_displayId);
			int function_call_retval = 			this->rcGetColorBufferDisplay(var_colorBuffer, (uint32_t*)(outptr_displayId.get()));
			std::memcpy(&tmpBuf[0 + size_displayId], &function_call_retval, sizeof(int));
			outptr_displayId.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetColorBufferDisplay");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetDisplayPose: {
			gfxstream::base::beginTrace("rcGetDisplayPose decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_x __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t size_y __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_w __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_h __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetDisplayPose: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_x;
			totalTmpSize += size_y;
			totalTmpSize += size_w;
			totalTmpSize += size_h;
			totalTmpSize += sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_x(&tmpBuf[0], size_x);
			OutputBuffer outptr_y(&tmpBuf[0 + size_x], size_y);
			OutputBuffer outptr_w(&tmpBuf[0 + size_x + size_y], size_w);
			OutputBuffer outptr_h(&tmpBuf[0 + size_x + size_y + size_w], size_h);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetDisplayPose(displayId:0x%08x x:%p(%u) y:%p(%u) w:%p(%u) h:%p(%u) )", stream, var_displayId, (GLint*)(outptr_x.get()), size_x, (GLint*)(outptr_y.get()), size_y, (uint32_t*)(outptr_w.get()), size_w, (uint32_t*)(outptr_h.get()), size_h);
			int function_call_retval = 			this->rcGetDisplayPose(var_displayId, (GLint*)(outptr_x.get()), (GLint*)(outptr_y.get()), (uint32_t*)(outptr_w.get()), (uint32_t*)(outptr_h.get()));
			std::memcpy(&tmpBuf[0 + size_x + size_y + size_w + size_h], &function_call_retval, sizeof(int));
			outptr_x.flush();
			outptr_y.flush();
			outptr_w.flush();
			outptr_h.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetDisplayPose");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetDisplayPose: {
			gfxstream::base::beginTrace("rcSetDisplayPose decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t var_w = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t var_h = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetDisplayPose: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcSetDisplayPose(displayId:0x%08x x:0x%08x y:0x%08x w:0x%08x h:0x%08x )", stream, var_displayId, var_x, var_y, var_w, var_h);
			int function_call_retval = 			this->rcSetDisplayPose(var_displayId, var_x, var_y, var_w, var_h);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcSetDisplayPose");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetColorBufferVulkanMode: {
			gfxstream::base::beginTrace("rcSetColorBufferVulkanMode decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_mode = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetColorBufferVulkanMode: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcSetColorBufferVulkanMode(colorBuffer:0x%08x mode:0x%08x )", stream, var_colorBuffer, var_mode);
			GLint function_call_retval = 			this->rcSetColorBufferVulkanMode(var_colorBuffer, var_mode);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(GLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcSetColorBufferVulkanMode");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcReadColorBufferYUV: {
			gfxstream::base::beginTrace("rcReadColorBufferYUV decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t var_pixels_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcReadColorBufferYUV: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_pixels;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pixels(&tmpBuf[0], size_pixels);
			DECODER_DEBUG_LOG("renderControl(%p): rcReadColorBufferYUV(colorbuffer:0x%08x x:0x%08x y:0x%08x width:0x%08x height:0x%08x pixels:%p(%u) pixels_size:0x%08x )", stream, var_colorbuffer, var_x, var_y, var_width, var_height, (void*)(outptr_pixels.get()), size_pixels, var_pixels_size);
			this->rcReadColorBufferYUV(var_colorbuffer, var_x, var_y, var_width, var_height, (void*)(outptr_pixels.get()), var_pixels_size);
			outptr_pixels.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcReadColorBufferYUV");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcIsSyncSignaled: {
			gfxstream::base::beginTrace("rcIsSyncSignaled decode");
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcIsSyncSignaled: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcIsSyncSignaled(sync:0x%016lx )", stream, var_sync);
			int function_call_retval = 			this->rcIsSyncSignaled(var_sync);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcIsSyncSignaled");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateColorBufferWithHandle: {
			gfxstream::base::beginTrace("rcCreateColorBufferWithHandle decode");
			uint32_t var_width = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_height = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			GLenum var_internalFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t var_handle = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateColorBufferWithHandle: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateColorBufferWithHandle(width:0x%08x height:0x%08x internalFormat:0x%08x handle:0x%08x )", stream, var_width, var_height, var_internalFormat, var_handle);
			this->rcCreateColorBufferWithHandle(var_width, var_height, var_internalFormat, var_handle);
			SET_LASTCALL("rcCreateColorBufferWithHandle");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateBuffer: {
			gfxstream::base::beginTrace("rcCreateBuffer decode");
			uint32_t var_size = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateBuffer: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateBuffer(size:0x%08x )", stream, var_size);
			uint32_t function_call_retval = 			this->rcCreateBuffer(var_size);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCloseBuffer: {
			gfxstream::base::beginTrace("rcCloseBuffer decode");
			uint32_t var_buffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCloseBuffer: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcCloseBuffer(buffer:0x%08x )", stream, var_buffer);
			this->rcCloseBuffer(var_buffer);
			SET_LASTCALL("rcCloseBuffer");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetColorBufferVulkanMode2: {
			gfxstream::base::beginTrace("rcSetColorBufferVulkanMode2 decode");
			uint32_t var_colorBuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_mode = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_memoryProperty = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetColorBufferVulkanMode2: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcSetColorBufferVulkanMode2(colorBuffer:0x%08x mode:0x%08x memoryProperty:0x%08x )", stream, var_colorBuffer, var_mode, var_memoryProperty);
			GLint function_call_retval = 			this->rcSetColorBufferVulkanMode2(var_colorBuffer, var_mode, var_memoryProperty);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(GLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcSetColorBufferVulkanMode2");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcMapGpaToBufferHandle: {
			gfxstream::base::beginTrace("rcMapGpaToBufferHandle decode");
			uint32_t var_bufferHandle = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint64_t var_gpa = Unpack<uint64_t,uint64_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 8, ptr + 8 + 4 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcMapGpaToBufferHandle: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcMapGpaToBufferHandle(bufferHandle:0x%08x gpa:0x%016lx )", stream, var_bufferHandle, var_gpa);
			int function_call_retval = 			this->rcMapGpaToBufferHandle(var_bufferHandle, var_gpa);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcMapGpaToBufferHandle");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateBuffer2: {
			gfxstream::base::beginTrace("rcCreateBuffer2 decode");
			uint64_t var_size = Unpack<uint64_t,uint64_t>(ptr + 8);
			uint32_t var_memoryProperty = Unpack<uint32_t,uint32_t>(ptr + 8 + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4, ptr + 8 + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateBuffer2: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(uint32_t);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateBuffer2(size:0x%016lx memoryProperty:0x%08x )", stream, var_size, var_memoryProperty);
			uint32_t function_call_retval = 			this->rcCreateBuffer2(var_size, var_memoryProperty);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(uint32_t));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateBuffer2");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcMapGpaToBufferHandle2: {
			gfxstream::base::beginTrace("rcMapGpaToBufferHandle2 decode");
			uint32_t var_bufferHandle = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint64_t var_gpa = Unpack<uint64_t,uint64_t>(ptr + 8 + 4);
			uint64_t var_size = Unpack<uint64_t,uint64_t>(ptr + 8 + 4 + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 8 + 8, ptr + 8 + 4 + 8 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcMapGpaToBufferHandle2: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcMapGpaToBufferHandle2(bufferHandle:0x%08x gpa:0x%016lx size:0x%016lx )", stream, var_bufferHandle, var_gpa, var_size);
			int function_call_retval = 			this->rcMapGpaToBufferHandle2(var_bufferHandle, var_gpa, var_size);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcMapGpaToBufferHandle2");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcFlushWindowColorBufferAsyncWithFrameNumber: {
			gfxstream::base::beginTrace("rcFlushWindowColorBufferAsyncWithFrameNumber decode");
			uint32_t var_windowSurface = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_frameNumber = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcFlushWindowColorBufferAsyncWithFrameNumber: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcFlushWindowColorBufferAsyncWithFrameNumber(windowSurface:0x%08x frameNumber:0x%08x )", stream, var_windowSurface, var_frameNumber);
			this->rcFlushWindowColorBufferAsyncWithFrameNumber(var_windowSurface, var_frameNumber);
			SET_LASTCALL("rcFlushWindowColorBufferAsyncWithFrameNumber");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetTracingForPuid: {
			gfxstream::base::beginTrace("rcSetTracingForPuid decode");
			uint64_t var_puid = Unpack<uint64_t,uint64_t>(ptr + 8);
			uint32_t var_enable = Unpack<uint32_t,uint32_t>(ptr + 8 + 8);
			uint64_t var_guestTime = Unpack<uint64_t,uint64_t>(ptr + 8 + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8 + 4 + 8, ptr + 8 + 8 + 4 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetTracingForPuid: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcSetTracingForPuid(puid:0x%016lx enable:0x%08x guestTime:0x%016lx )", stream, var_puid, var_enable, var_guestTime);
			this->rcSetTracingForPuid(var_puid, var_enable, var_guestTime);
			SET_LASTCALL("rcSetTracingForPuid");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcMakeCurrentAsync: {
			gfxstream::base::beginTrace("rcMakeCurrentAsync decode");
			uint32_t var_context = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t var_drawSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			uint32_t var_readSurf = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcMakeCurrentAsync: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcMakeCurrentAsync(context:0x%08x drawSurf:0x%08x readSurf:0x%08x )", stream, var_context, var_drawSurf, var_readSurf);
			this->rcMakeCurrentAsync(var_context, var_drawSurf, var_readSurf);
			SET_LASTCALL("rcMakeCurrentAsync");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcComposeAsync: {
			gfxstream::base::beginTrace("rcComposeAsync decode");
			uint32_t var_bufferSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffer(ptr + 8 + 4 + 4, size_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_buffer, ptr + 8 + 4 + 4 + size_buffer, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcComposeAsync: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcComposeAsync(bufferSize:0x%08x buffer:%p(%u) )", stream, var_bufferSize, (void*)(inptr_buffer.get()), size_buffer);
			this->rcComposeAsync(var_bufferSize, (void*)(inptr_buffer.get()));
			SET_LASTCALL("rcComposeAsync");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcDestroySyncKHRAsync: {
			gfxstream::base::beginTrace("rcDestroySyncKHRAsync decode");
			uint64_t var_sync = Unpack<uint64_t,uint64_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 8, ptr + 8 + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcDestroySyncKHRAsync: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcDestroySyncKHRAsync(sync:0x%016lx )", stream, var_sync);
			this->rcDestroySyncKHRAsync(var_sync);
			SET_LASTCALL("rcDestroySyncKHRAsync");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcComposeWithoutPost: {
			gfxstream::base::beginTrace("rcComposeWithoutPost decode");
			uint32_t var_bufferSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffer(ptr + 8 + 4 + 4, size_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_buffer, ptr + 8 + 4 + 4 + size_buffer, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcComposeWithoutPost: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcComposeWithoutPost(bufferSize:0x%08x buffer:%p(%u) )", stream, var_bufferSize, (void*)(inptr_buffer.get()), size_buffer);
			GLint function_call_retval = 			this->rcComposeWithoutPost(var_bufferSize, (void*)(inptr_buffer.get()));
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(GLint));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcComposeWithoutPost");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcComposeAsyncWithoutPost: {
			gfxstream::base::beginTrace("rcComposeAsyncWithoutPost decode");
			uint32_t var_bufferSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffer(ptr + 8 + 4 + 4, size_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + size_buffer, ptr + 8 + 4 + 4 + size_buffer, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcComposeAsyncWithoutPost: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcComposeAsyncWithoutPost(bufferSize:0x%08x buffer:%p(%u) )", stream, var_bufferSize, (void*)(inptr_buffer.get()), size_buffer);
			this->rcComposeAsyncWithoutPost(var_bufferSize, (void*)(inptr_buffer.get()));
			SET_LASTCALL("rcComposeAsyncWithoutPost");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcCreateDisplayById: {
			gfxstream::base::beginTrace("rcCreateDisplayById decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4, ptr + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcCreateDisplayById: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcCreateDisplayById(displayId:0x%08x )", stream, var_displayId);
			int function_call_retval = 			this->rcCreateDisplayById(var_displayId);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcCreateDisplayById");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetDisplayPoseDpi: {
			gfxstream::base::beginTrace("rcSetDisplayPoseDpi decode");
			uint32_t var_displayId = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t var_w = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t var_h = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t var_dpi = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetDisplayPoseDpi: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcSetDisplayPoseDpi(displayId:0x%08x x:0x%08x y:0x%08x w:0x%08x h:0x%08x dpi:0x%08x )", stream, var_displayId, var_x, var_y, var_w, var_h, var_dpi);
			int function_call_retval = 			this->rcSetDisplayPoseDpi(var_displayId, var_x, var_y, var_w, var_h, var_dpi);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcSetDisplayPoseDpi");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcReadColorBufferDMA: {
			gfxstream::base::beginTrace("rcReadColorBufferDMA decode");
			uint32_t var_colorbuffer = Unpack<uint32_t,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_width = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_height = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint64_t var_pixels_guest_paddr = Unpack<uint64_t,uint64_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			void* var_pixels = stream->getDmaForReading(var_pixels_guest_paddr);
			uint32_t size_pixels __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8);
			uint32_t var_pixels_size = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 8 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcReadColorBufferDMA: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcReadColorBufferDMA(colorbuffer:0x%08x x:0x%08x y:0x%08x width:0x%08x height:0x%08x format:0x%08x type:0x%08x pixels:%p(%u) pixels_size:0x%08x )", stream, var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, var_pixels, var_pixels_size);
			int function_call_retval = 			this->rcReadColorBufferDMA(var_colorbuffer, var_x, var_y, var_width, var_height, var_format, var_type, var_pixels, var_pixels_size);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			stream->unlockDma(var_pixels_guest_paddr);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcReadColorBufferDMA");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetFBDisplayConfigsCount: {
			gfxstream::base::beginTrace("rcGetFBDisplayConfigsCount decode");
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetFBDisplayConfigsCount: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetFBDisplayConfigsCount()", stream);
			int function_call_retval = 			this->rcGetFBDisplayConfigsCount();
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetFBDisplayConfigsCount");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetFBDisplayConfigsParam: {
			gfxstream::base::beginTrace("rcGetFBDisplayConfigsParam decode");
			int var_configId = Unpack<int,uint32_t>(ptr + 8);
			EGLint var_param = Unpack<EGLint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetFBDisplayConfigsParam: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetFBDisplayConfigsParam(configId:%d param:0x%08x )", stream, var_configId, var_param);
			int function_call_retval = 			this->rcGetFBDisplayConfigsParam(var_configId, var_param);
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetFBDisplayConfigsParam");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetFBDisplayActiveConfig: {
			gfxstream::base::beginTrace("rcGetFBDisplayActiveConfig decode");
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8, ptr + 8, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetFBDisplayActiveConfig: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetFBDisplayActiveConfig()", stream);
			int function_call_retval = 			this->rcGetFBDisplayActiveConfig();
			std::memcpy(&tmpBuf[0], &function_call_retval, sizeof(int));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetFBDisplayActiveConfig");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcSetProcessMetadata: {
			gfxstream::base::beginTrace("rcSetProcessMetadata decode");
			uint32_t size_key __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_key(ptr + 8 + 4, size_key);
			uint32_t size_valuePtr __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_key);
			InputBuffer inptr_valuePtr(ptr + 8 + 4 + size_key + 4, size_valuePtr);
			uint32_t var_valueSize = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_key + 4 + size_valuePtr);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + size_key + 4 + size_valuePtr + 4, ptr + 8 + 4 + size_key + 4 + size_valuePtr + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcSetProcessMetadata: GL checksumCalculator failure\n");
			}
			DECODER_DEBUG_LOG("renderControl(%p): rcSetProcessMetadata(key:%p(%u) valuePtr:%p(%u) valueSize:0x%08x )", stream, (char*)(inptr_key.get()), size_key, (RenderControlByte*)(inptr_valuePtr.get()), size_valuePtr, var_valueSize);
			this->rcSetProcessMetadata((char*)(inptr_key.get()), (RenderControlByte*)(inptr_valuePtr.get()), var_valueSize);
			SET_LASTCALL("rcSetProcessMetadata");
			gfxstream::base::endTrace();
			break;
		}
		case OP_rcGetHostExtensionsString: {
			gfxstream::base::beginTrace("rcGetHostExtensionsString decode");
			uint32_t var_bufferSize = Unpack<uint32_t,uint32_t>(ptr + 8);
			uint32_t size_buffer __attribute__((unused)) = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(checksumCalc, ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize,
					"renderControl_decoder_context_t::decode, OP_rcGetHostExtensionsString: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffer;
			totalTmpSize += sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffer(&tmpBuf[0], size_buffer);
			DECODER_DEBUG_LOG("renderControl(%p): rcGetHostExtensionsString(bufferSize:0x%08x buffer:%p(%u) )", stream, var_bufferSize, (void*)(outptr_buffer.get()), size_buffer);
			int function_call_retval = 			this->rcGetHostExtensionsString(var_bufferSize, (void*)(outptr_buffer.get()));
			std::memcpy(&tmpBuf[0 + size_buffer], &function_call_retval, sizeof(int));
			outptr_buffer.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(checksumCalc, &tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("rcGetHostExtensionsString");
			gfxstream::base::endTrace();
			break;
		}
		default:
			return ptr - (unsigned char*)buf;
		} //switch
		ptr += packetLen;
	} // while
	return ptr - (unsigned char*)buf;
}
}  // namespace gfxstream

