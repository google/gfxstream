// Copyright 2018 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#pragma once

#include <vulkan/vulkan.h>

#include <memory>
#include <optional>
#include <unordered_map>
#include <utility>
#include <vector>

#include "VkDecoderContext.h"
#include "VkQsriTimeline.h"
#include "VkSnapshotApiCall.h"
#include "VulkanBoxedHandles.h"
#include "VulkanDispatch.h"
#include "VulkanHandleMapping.h"
#include "gfxstream/AsyncResult.h"
#include "gfxstream/HealthMonitor.h"
#include "gfxstream/synchronization/Lock.h"
#include "cereal/common/goldfish_vk_transform.h"
#include "gfxstream/host/Features.h"
#include "goldfish_vk_private_defs.h"
#include "utils/GfxApiLogger.h"
#include "vk_util.h"

using gfxstream::base::AutoLock;
using gfxstream::base::Lock;

namespace gfxstream {
namespace base {
class BumpPool;
class Stream;
}  // namespace base
}  // namespace android

namespace gfxstream {
namespace vk {

class VkDecoderSnapshot;
class VkEmulation;

// Class for tracking host-side state. Currently we only care about
// tracking VkDeviceMemory to make it easier to pass the right data
// from mapped pointers to the guest, but this could get more stuff
// added to it if for instance, we want to only expose a certain set
// of physical device capabilities, or do snapshots.

// This class may be autogenerated in the future.
// Currently, it works by interfacing with VkDecoder calling on_<apicall>
// functions.
class VkDecoderGlobalState {
   public:
    VkDecoderGlobalState(VkEmulation* emulation);
    ~VkDecoderGlobalState();

    static void initialize(VkEmulation* emulation);

    // There should only be one instance of VkDecoderGlobalState per process
    // Note: currently not thread-safe
    static VkDecoderGlobalState* get();

    // For testing only - destroys the global instance of VkDecoderGlobalState.
    static void reset();

    // Snapshot save/load
    bool snapshotsEnabled() const;
    bool isSnapshotCurrentlyLoading() const;

    bool batchedDescriptorSetUpdateEnabled() const;

    const gfxstream::host::FeatureSet& getFeatures() const;

    // Whether to clean up VK instance.
    // bug 149997534
    bool vkCleanupEnabled() const;

    void save(android::base::Stream* stream);
    void load(android::base::Stream* stream, emugl::GfxApiLogger& gfxLogger,
              HealthMonitor<>* healthMonitor);

    VkResult on_vkEnumerateInstanceVersion(gfxstream::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* snapshotInfo,
                                           uint32_t* pApiVersion);
    VkResult on_vkEnumerateInstanceExtensionProperties(gfxstream::base::BumpPool* pool,
                                                       VkSnapshotApiCallInfo* snapshotInfo,
                                                       const char* pLayerName,
                                                       uint32_t* pPropertyCount,
                                                       VkExtensionProperties* pProperties);

    VkResult on_vkCreateInstance(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 const VkInstanceCreateInfo* pCreateInfo,
                                 const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);

    void on_vkDestroyInstance(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkInstance instance, const VkAllocationCallbacks* pAllocator);

    VkResult on_vkEnumeratePhysicalDevices(gfxstream::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
                                           uint32_t* physicalDeviceCount,
                                           VkPhysicalDevice* physicalDevices);

    // Override features
    void on_vkGetPhysicalDeviceFeatures(gfxstream::base::BumpPool* pool,
                                        VkSnapshotApiCallInfo* snapshotInfo,
                                        VkPhysicalDevice physicalDevice,
                                        VkPhysicalDeviceFeatures* pFeatures);
    void on_vkGetPhysicalDeviceFeatures2(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo,
                                         VkPhysicalDevice physicalDevice,
                                         VkPhysicalDeviceFeatures2* pFeatures);
    void on_vkGetPhysicalDeviceFeatures2KHR(gfxstream::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* snapshotInfo,
                                            VkPhysicalDevice physicalDevice,
                                            VkPhysicalDeviceFeatures2* pFeatures);

    // Override image format properties
    VkResult on_vkGetPhysicalDeviceImageFormatProperties(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling,
        VkImageUsageFlags usage, VkImageCreateFlags flags,
        VkImageFormatProperties* pImageFormatProperties);
    VkResult on_vkGetPhysicalDeviceImageFormatProperties2(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties);
    VkResult on_vkGetPhysicalDeviceImageFormatProperties2KHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2* pImageFormatInfo,
        VkImageFormatProperties2* pImageFormatProperties);

    // Override format features
    void on_vkGetPhysicalDeviceFormatProperties(gfxstream::base::BumpPool* pool,
                                                VkSnapshotApiCallInfo* snapshotInfo,
                                                VkPhysicalDevice physicalDevice, VkFormat format,
                                                VkFormatProperties* pFormatProperties);
    void on_vkGetPhysicalDeviceFormatProperties2(gfxstream::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkPhysicalDevice physicalDevice, VkFormat format,
                                                 VkFormatProperties2* pFormatProperties);
    void on_vkGetPhysicalDeviceFormatProperties2KHR(gfxstream::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                    VkPhysicalDevice physicalDevice,
                                                    VkFormat format,
                                                    VkFormatProperties2* pFormatProperties);

    // Override API version
    void on_vkGetPhysicalDeviceProperties(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo,
                                          VkPhysicalDevice physicalDevice,
                                          VkPhysicalDeviceProperties* pProperties);
    void on_vkGetPhysicalDeviceProperties2(gfxstream::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* snapshotInfo,
                                           VkPhysicalDevice physicalDevice,
                                           VkPhysicalDeviceProperties2* pProperties);
    void on_vkGetPhysicalDeviceProperties2KHR(gfxstream::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* snapshotInfo,
                                              VkPhysicalDevice physicalDevice,
                                              VkPhysicalDeviceProperties2* pProperties);

    // Override queue properties
    void on_vkGetPhysicalDeviceQueueFamilyProperties(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
        VkQueueFamilyProperties* pQueueFamilyProperties);
    void on_vkGetPhysicalDeviceQueueFamilyProperties2(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, uint32_t* pQueueFamilyPropertyCount,
        VkQueueFamilyProperties2* pQueueFamilyProperties);

    // Override memory types advertised from host
    //
    void on_vkGetPhysicalDeviceMemoryProperties(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties* pMemoryProperties);
    void on_vkGetPhysicalDeviceMemoryProperties2(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);
    void on_vkGetPhysicalDeviceMemoryProperties2KHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2* pMemoryProperties);

    // Override supported device extension lists
    VkResult on_vkEnumerateDeviceExtensionProperties(gfxstream::base::BumpPool* pool,
                                                     VkSnapshotApiCallInfo* snapshotInfo,
                                                     VkPhysicalDevice physicalDevice,
                                                     const char* pLayerName,
                                                     uint32_t* pPropertyCount,
                                                     VkExtensionProperties* pProperties);

    VkResult on_vkCreateDevice(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkPhysicalDevice physicalDevice,
                               const VkDeviceCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);

    void on_vkGetDeviceQueue(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                             VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex,
                             VkQueue* pQueue);

    void on_vkGetDeviceQueue2(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkDevice device, const VkDeviceQueueInfo2* pQueueInfo,
                              VkQueue* pQueue);

    void on_vkGetPhysicalDeviceSparseImageFormatProperties(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type,
        VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling,
        uint32_t* pPropertyCount, VkSparseImageFormatProperties* pProperties);
    void on_vkGetPhysicalDeviceSparseImageFormatProperties2(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);
    void on_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2* pFormatInfo,
        uint32_t* pPropertyCount, VkSparseImageFormatProperties2* pProperties);

    void on_vkDestroyDevice(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                            VkDevice device, const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreateBuffer(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkDevice device, const VkBufferCreateInfo* pCreateInfo,
                               const VkAllocationCallbacks* pAllocator, VkBuffer* pBuffer);

    void on_vkDestroyBuffer(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                            VkDevice device, VkBuffer buffer,
                            const VkAllocationCallbacks* pAllocator);

    VkResult on_vkBindBufferMemory(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   VkBuffer buffer, VkDeviceMemory memory,
                                   VkDeviceSize memoryOffset);
    VkResult on_vkBindBufferMemory2(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    uint32_t bindInfoCount,
                                    const VkBindBufferMemoryInfo* pBindInfos);
    VkResult on_vkBindBufferMemory2KHR(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       uint32_t bindInfoCount,
                                       const VkBindBufferMemoryInfo* pBindInfos);

    VkResult on_vkCreateImage(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkDevice device, const VkImageCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkImage* pImage);

    void on_vkDestroyImage(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                           VkDevice device, VkImage image, const VkAllocationCallbacks* pAllocator);

    VkResult on_vkBindImageMemory(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                  VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset);
    // It might modify pBindInfos to support snapshot.
    VkResult on_vkBindImageMemory2(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   uint32_t bindInfoCount, const VkBindImageMemoryInfo* pBindInfos);
    // It might modify pBindInfos to support snapshot.
    VkResult on_vkBindImageMemory2KHR(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      uint32_t bindInfoCount,
                                      const VkBindImageMemoryInfo* pBindInfos);

    VkResult on_vkCreateImageView(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                  const VkImageViewCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkImageView* pView);

    void on_vkDestroyImageView(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkDevice device, VkImageView imageView,
                               const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreateSampler(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                VkDevice device, const VkSamplerCreateInfo* pCreateInfo,
                                const VkAllocationCallbacks* pAllocator, VkSampler* pSampler);

    void on_vkDestroySampler(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                             VkDevice device, VkSampler sampler,
                             const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreateDescriptorSetLayout(gfxstream::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                            const VkDescriptorSetLayoutCreateInfo* pCreateInfo,
                                            const VkAllocationCallbacks* pAllocator,
                                            VkDescriptorSetLayout* pSetLayout);

    void on_vkDestroyDescriptorSetLayout(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         VkDescriptorSetLayout descriptorSetLayout,
                                         const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreateDescriptorPool(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       const VkDescriptorPoolCreateInfo* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkDescriptorPool* pDescriptorPool);

    void on_vkDestroyDescriptorPool(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    VkDescriptorPool descriptorPool,
                                    const VkAllocationCallbacks* pAllocator);

    VkResult on_vkResetDescriptorPool(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      VkDescriptorPool descriptorPool,
                                      VkDescriptorPoolResetFlags flags);

    VkResult on_vkAllocateDescriptorSets(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         const VkDescriptorSetAllocateInfo* pAllocateInfo,
                                         VkDescriptorSet* pDescriptorSets);

    VkResult on_vkFreeDescriptorSets(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     VkDescriptorPool descriptorPool, uint32_t descriptorSetCount,
                                     const VkDescriptorSet* pDescriptorSets);

    void on_vkUpdateDescriptorSets(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   uint32_t descriptorWriteCount,
                                   const VkWriteDescriptorSet* pDescriptorWrites,
                                   uint32_t descriptorCopyCount,
                                   const VkCopyDescriptorSet* pDescriptorCopies);

    VkResult on_vkCreateShaderModule(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                     const VkShaderModuleCreateInfo* pCreateInfo,
                                     const VkAllocationCallbacks* pAllocator,
                                     VkShaderModule* pShaderModule);

    void on_vkDestroyShaderModule(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                  VkShaderModule shaderModule,
                                  const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreatePipelineCache(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      const VkPipelineCacheCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkPipelineCache* pPipelineCache);

    void on_vkDestroyPipelineCache(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   VkPipelineCache pipelineCache,
                                   const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreatePipelineLayout(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      const VkPipelineLayoutCreateInfo* pCreateInfo,
                                      const VkAllocationCallbacks* pAllocator,
                                      VkPipelineLayout* pPipelineLayout);

    void on_vkDestroyPipelineLayout(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   VkPipelineLayout pipelineLayout,
                                   const VkAllocationCallbacks* pAllocator);

    VkResult on_vkCreateGraphicsPipelines(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                          const VkGraphicsPipelineCreateInfo* pCreateInfos,
                                          const VkAllocationCallbacks* pAllocator,
                                          VkPipeline* pPipelines);

    VkResult on_vkCreateComputePipelines(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         VkPipelineCache pipelineCache, uint32_t createInfoCount,
                                         const VkComputePipelineCreateInfo* pCreateInfos,
                                         const VkAllocationCallbacks* pAllocator,
                                         VkPipeline* pPipelines);

    void on_vkDestroyPipeline(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkDevice device, VkPipeline pipeline,
                              const VkAllocationCallbacks* pAllocator);

    void on_vkCmdCopyBufferToImage(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo,
                                   VkCommandBuffer commandBuffer, VkBuffer srcBuffer,
                                   VkImage dstImage, VkImageLayout dstImageLayout,
                                   uint32_t regionCount, const VkBufferImageCopy* pRegions,
                                   const VkDecoderContext& context);

    void on_vkCmdCopyImage(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                           VkCommandBuffer commandBuffer, VkImage srcImage,
                           VkImageLayout srcImageLayout, VkImage dstImage,
                           VkImageLayout dstImageLayout, uint32_t regionCount,
                           const VkImageCopy* pRegions);
    void on_vkCmdCopyImageToBuffer(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo,
                                   VkCommandBuffer commandBuffer, VkImage srcImage,
                                   VkImageLayout srcImageLayout, VkBuffer dstBuffer,
                                   uint32_t regionCount, const VkBufferImageCopy* pRegions);

    void on_vkCmdCopyBufferToImage2(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo,
                                    VkCommandBuffer commandBuffer,
                                    const VkCopyBufferToImageInfo2* pCopyBufferToImageInfo,
                                    const VkDecoderContext& context);

    void on_vkCmdCopyImage2(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                            VkCommandBuffer commandBuffer, const VkCopyImageInfo2* pCopyImageInfo);
    void on_vkCmdCopyImageToBuffer2(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo,
                                    VkCommandBuffer commandBuffer,
                                    const VkCopyImageToBufferInfo2* pCopyImageToBufferInfo);

    void on_vkCmdCopyBufferToImage2KHR(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo,
                                       VkCommandBuffer commandBuffer,
                                       const VkCopyBufferToImageInfo2KHR* pCopyBufferToImageInfo,
                                       const VkDecoderContext& context);

    void on_vkCmdCopyImage2KHR(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkCommandBuffer commandBuffer,
                               const VkCopyImageInfo2KHR* pCopyImageInfo);
    void on_vkCmdCopyImageToBuffer2KHR(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo,
                                       VkCommandBuffer commandBuffer,
                                       const VkCopyImageToBufferInfo2KHR* pCopyImageToBufferInfo);

    void on_vkGetImageMemoryRequirements(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         VkImage image, VkMemoryRequirements* pMemoryRequirements);

    void on_vkGetImageMemoryRequirements2(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          const VkImageMemoryRequirementsInfo2* pInfo,
                                          VkMemoryRequirements2* pMemoryRequirements);

    void on_vkGetImageMemoryRequirements2KHR(gfxstream::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                             const VkImageMemoryRequirementsInfo2* pInfo,
                                             VkMemoryRequirements2* pMemoryRequirements);

    void on_vkGetBufferMemoryRequirements(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          VkBuffer buffer,
                                          VkMemoryRequirements* pMemoryRequirements);

    void on_vkGetBufferMemoryRequirements2(gfxstream::base::BumpPool* pool,
                                           VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                           const VkBufferMemoryRequirementsInfo2* pInfo,
                                           VkMemoryRequirements2* pMemoryRequirements);

    void on_vkGetBufferMemoryRequirements2KHR(gfxstream::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                              const VkBufferMemoryRequirementsInfo2* pInfo,
                                              VkMemoryRequirements2* pMemoryRequirements);

    void on_vkCmdPipelineBarrier(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask,
                                 VkPipelineStageFlags dstStageMask,
                                 VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount,
                                 const VkMemoryBarrier* pMemoryBarriers,
                                 uint32_t bufferMemoryBarrierCount,
                                 const VkBufferMemoryBarrier* pBufferMemoryBarriers,
                                 uint32_t imageMemoryBarrierCount,
                                 const VkImageMemoryBarrier* pImageMemoryBarriers);

    void on_vkCmdPipelineBarrier2(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo,
                                  VkCommandBuffer commandBuffer,
                                  const VkDependencyInfo* pDependencyInfo);

    // Do we need to wrap vk(Create|Destroy)Instance to
    // update our maps of VkDevices? Spec suggests no:
    // https://www.khronos.org/registry/vulkan/specs/1.1-extensions/man/html/vkDestroyInstance.html
    // Valid Usage
    // All child objects created using instance
    // must have been destroyed prior to destroying instance
    //
    // This suggests that we should emulate the invalid behavior by
    // not destroying our own VkDevice maps on instance destruction.

    VkResult on_vkAllocateMemory(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkDevice device, const VkMemoryAllocateInfo* pAllocateInfo,
                                 const VkAllocationCallbacks* pAllocator, VkDeviceMemory* pMemory);

    void on_vkFreeMemory(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                         VkDevice device, VkDeviceMemory memory,
                         const VkAllocationCallbacks* pAllocator);

    VkResult on_vkMapMemory(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                            VkDevice device, VkDeviceMemory memory, VkDeviceSize offset,
                            VkDeviceSize size, VkMemoryMapFlags flags, void** ppData);

    void on_vkUnmapMemory(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                          VkDevice device, VkDeviceMemory memory);

    uint8_t* getMappedHostPointer(VkDeviceMemory memory);
    VkDeviceSize getDeviceMemorySize(VkDeviceMemory memory);
    bool usingDirectMapping() const;

    struct HostFeatureSupport {
        bool supportsVulkan = false;
        bool supportsVulkan1_1 = false;
        bool useDeferredCommands = false;
        bool useCreateResourcesWithRequirements = false;
        uint32_t apiVersion = 0;
        uint32_t driverVersion = 0;
        uint32_t deviceID = 0;
        uint32_t vendorID = 0;
    };

    HostFeatureSupport getHostFeatureSupport() const;

    // VK_ANDROID_native_buffer
    VkResult on_vkGetSwapchainGrallocUsageANDROID(gfxstream::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* snapshotInfo,
                                                  VkDevice device, VkFormat format,
                                                  VkImageUsageFlags imageUsage, int* grallocUsage);
    VkResult on_vkGetSwapchainGrallocUsage2ANDROID(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
        VkFormat format, VkImageUsageFlags imageUsage,
        VkSwapchainImageUsageFlagsANDROID swapchainImageUsage, uint64_t* grallocConsumerUsage,
        uint64_t* grallocProducerUsage);
    VkResult on_vkAcquireImageANDROID(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                      VkImage image, int nativeFenceFd, VkSemaphore semaphore,
                                      VkFence fence);
    VkResult on_vkQueueSignalReleaseImageANDROID(gfxstream::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                                 uint32_t waitSemaphoreCount,
                                                 const VkSemaphore* pWaitSemaphores, VkImage image,
                                                 int* pNativeFenceFd);

    // VK_GOOGLE_gfxstream
    VkResult on_vkMapMemoryIntoAddressSpaceGOOGLE(gfxstream::base::BumpPool* pool,
                                                  VkSnapshotApiCallInfo* snapshotInfo,
                                                  VkDevice device, VkDeviceMemory memory,
                                                  uint64_t* pAddress);
    VkResult on_vkGetMemoryHostAddressInfoGOOGLE(gfxstream::base::BumpPool* pool,
                                                 VkSnapshotApiCallInfo* snapshotInfo,
                                                 VkDevice device, VkDeviceMemory memory,
                                                 uint64_t* pAddress, uint64_t* pSize,
                                                 uint64_t* pHostmemId);
    VkResult on_vkGetBlobGOOGLE(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                VkDevice device, VkDeviceMemory memory);

    VkResult on_vkFreeMemorySyncGOOGLE(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       VkDeviceMemory memory,
                                       const VkAllocationCallbacks* pAllocator);

    VkResult on_vkAllocateCommandBuffers(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         const VkCommandBufferAllocateInfo* pAllocateInfo,
                                         VkCommandBuffer* pCommandBuffers);

    void on_vkCmdExecuteCommands(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkCommandBuffer commandBuffer, uint32_t commandBufferCount,
                                 const VkCommandBuffer* pCommandBuffers);

    VkResult on_vkQueueSubmit(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkQueue queue, uint32_t submitCount, const VkSubmitInfo* pSubmits,
                              VkFence fence);

    VkResult on_vkQueueSubmit2(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkQueue queue, uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                               VkFence fence);

    VkResult on_vkQueueWaitIdle(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                VkQueue queue);

    VkResult on_vkResetCommandBuffer(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo,
                                     VkCommandBuffer commandBuffer,
                                     VkCommandBufferResetFlags flags);

    void on_vkFreeCommandBuffers(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkDevice device, VkCommandPool commandPool,
                                 uint32_t commandBufferCount,
                                 const VkCommandBuffer* pCommandBuffers);

    VkResult on_vkCreateCommandPool(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    const VkCommandPoolCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkCommandPool* pCommandPool);

    void on_vkDestroyCommandPool(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkDevice device, VkCommandPool commandPool,
                                 const VkAllocationCallbacks* pAllocator);

    VkResult on_vkResetCommandPool(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   VkCommandPool commandPool, VkCommandPoolResetFlags flags);

    void on_vkGetPhysicalDeviceExternalSemaphoreProperties(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties);

    void on_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkPhysicalDevice physicalDevice,
        const VkPhysicalDeviceExternalSemaphoreInfo* pExternalSemaphoreInfo,
        VkExternalSemaphoreProperties* pExternalSemaphoreProperties);

    VkResult on_vkCreateSemaphore(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                  const VkSemaphoreCreateInfo* pCreateInfo,
                                  const VkAllocationCallbacks* pAllocator, VkSemaphore* pSemaphore);
    VkResult on_vkImportSemaphoreFdKHR(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       const VkImportSemaphoreFdInfoKHR* pImportSemaphoreFdInfo);
    VkResult on_vkGetSemaphoreFdKHR(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                    const VkSemaphoreGetFdInfoKHR* pGetFdInfo, int* pFd);
    VkResult on_vkGetSemaphoreGOOGLE(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
                                     VkSemaphore semaphore, uint64_t syncId);
    void on_vkDestroySemaphore(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                               VkDevice boxed_device, VkSemaphore semaphore,
                               const VkAllocationCallbacks* pAllocator);
    VkResult on_vkWaitSemaphores(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkDevice boxed_device, const VkSemaphoreWaitInfo* pWaitInfo, uint64_t timeout);
    VkResult on_vkSignalSemaphore(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
        VkDevice boxed_device, const VkSemaphoreSignalInfo* pSignalInfo);

    VkResult on_vkCreateFence(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkDevice device, const VkFenceCreateInfo* pCreateInfo,
                              const VkAllocationCallbacks* pAllocator, VkFence* pFence);
    VkResult on_vkGetFenceStatus(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkDevice device, VkFence pFence);
    VkResult on_vkWaitForFences(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                VkDevice device, uint32_t fenceCount, const VkFence* pFences,
                                VkBool32 waitAll, uint64_t timeout);
    VkResult on_vkResetFences(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkDevice device, uint32_t fenceCount, const VkFence* pFences);
    void on_vkDestroyFence(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                           VkDevice device, VkFence fence, const VkAllocationCallbacks* pAllocator);

    // Descriptor update templates
    VkResult on_vkCreateDescriptorUpdateTemplate(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);

    VkResult on_vkCreateDescriptorUpdateTemplateKHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
        const VkDescriptorUpdateTemplateCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator,
        VkDescriptorUpdateTemplate* pDescriptorUpdateTemplate);

    void on_vkDestroyDescriptorUpdateTemplate(gfxstream::base::BumpPool* pool,
                                              VkSnapshotApiCallInfo* snapshotInfo,
                                              VkDevice boxed_device,
                                              VkDescriptorUpdateTemplate descriptorUpdateTemplate,
                                              const VkAllocationCallbacks* pAllocator);

    void on_vkDestroyDescriptorUpdateTemplateKHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
        VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        const VkAllocationCallbacks* pAllocator);

    void on_vkUpdateDescriptorSetWithTemplateSizedGOOGLE(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
        const uint32_t* pImageInfoEntryIndices, const uint32_t* pBufferInfoEntryIndices,
        const uint32_t* pBufferViewEntryIndices, const VkDescriptorImageInfo* pImageInfos,
        const VkDescriptorBufferInfo* pBufferInfos, const VkBufferView* pBufferViews);

    void on_vkUpdateDescriptorSetWithTemplateSized2GOOGLE(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice boxed_device,
        VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate,
        uint32_t imageInfoCount, uint32_t bufferInfoCount, uint32_t bufferViewCount,
        uint32_t inlineUniformBlockCount, const uint32_t* pImageInfoEntryIndices,
        const uint32_t* pBufferInfoEntryIndices, const uint32_t* pBufferViewEntryIndices,
        const VkDescriptorImageInfo* pImageInfos, const VkDescriptorBufferInfo* pBufferInfos,
        const VkBufferView* pBufferViews, const uint8_t* pInlineUniformBlockData);

    VkResult on_vkBeginCommandBuffer(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo,
                                     VkCommandBuffer commandBuffer,
                                     const VkCommandBufferBeginInfo* pBeginInfo,
                                     const VkDecoderContext& context);
    void on_vkBeginCommandBufferAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* snapshotInfo,
                                            VkCommandBuffer commandBuffer,
                                            const VkCommandBufferBeginInfo* pBeginInfo,
                                            const VkDecoderContext& context);
    VkResult on_vkEndCommandBuffer(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo,
                                   VkCommandBuffer commandBuffer, const VkDecoderContext& context);
    void on_vkEndCommandBufferAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo,
                                          VkCommandBuffer commandBuffer,
                                          const VkDecoderContext& context);
    void on_vkResetCommandBufferAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* snapshotInfo,
                                            VkCommandBuffer commandBuffer,
                                            VkCommandBufferResetFlags flags);
    void on_vkCommandBufferHostSyncGOOGLE(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo,
                                          VkCommandBuffer commandBuffer, uint32_t needHostSync,
                                          uint32_t sequenceNumber);

    VkResult on_vkCreateImageWithRequirementsGOOGLE(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
        const VkImageCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
        VkImage* pImage, VkMemoryRequirements* pMemoryRequirements);
    VkResult on_vkCreateBufferWithRequirementsGOOGLE(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
        const VkBufferCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator,
        VkBuffer* pBuffer, VkMemoryRequirements* pMemoryRequirements);

    void on_vkCmdBindPipeline(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                              VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint,
                              VkPipeline pipeline);

    void on_vkCmdBindDescriptorSets(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo,
                                    VkCommandBuffer commandBuffer,
                                    VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout,
                                    uint32_t firstSet, uint32_t descriptorSetCount,
                                    const VkDescriptorSet* pDescriptorSets,
                                    uint32_t dynamicOffsetCount, const uint32_t* pDynamicOffsets);

    VkResult on_vkCreateRenderPass(gfxstream::base::BumpPool* pool,
                                   VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                   const VkRenderPassCreateInfo* pCreateInfo,
                                   const VkAllocationCallbacks* pAllocator,
                                   VkRenderPass* pRenderPass);
    VkResult on_vkCreateRenderPass2(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    const VkRenderPassCreateInfo2* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkRenderPass* pRenderPass);
    VkResult on_vkCreateRenderPass2KHR(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                       const VkRenderPassCreateInfo2KHR* pCreateInfo,
                                       const VkAllocationCallbacks* pAllocator,
                                       VkRenderPass* pRenderPass);
    void on_vkDestroyRenderPass(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                VkDevice device, VkRenderPass renderPass,
                                const VkAllocationCallbacks* pAllocator);
    void on_vkCmdBeginRenderPass(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkCommandBuffer commandBuffer,
                                 const VkRenderPassBeginInfo* pRenderPassBegin,
                                 VkSubpassContents contents);
    void on_vkCmdBeginRenderPass2(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo,
                                  VkCommandBuffer commandBuffer,
                                  const VkRenderPassBeginInfo* pRenderPassBegin,
                                  const VkSubpassBeginInfo* pSubpassBeginInfo);
    void on_vkCmdBeginRenderPass2KHR(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo,
                                     VkCommandBuffer commandBuffer,
                                     const VkRenderPassBeginInfo* pRenderPassBegin,
                                     const VkSubpassBeginInfo* pSubpassBeginInfo);

    VkResult on_vkCreateFramebuffer(gfxstream::base::BumpPool* pool,
                                    VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                    const VkFramebufferCreateInfo* pCreateInfo,
                                    const VkAllocationCallbacks* pAllocator,
                                    VkFramebuffer* pFramebuffer);
    void on_vkDestroyFramebuffer(gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo,
                                 VkDevice device, VkFramebuffer framebuffer,
                                 const VkAllocationCallbacks* pAllocator);

    void on_vkCmdCopyQueryPoolResults(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo,
                                      VkCommandBuffer commandBuffer, VkQueryPool queryPool,
                                      uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer,
                                      VkDeviceSize dstOffset, VkDeviceSize stride,
                                      VkQueryResultFlags flags);

    // VK_GOOGLE_gfxstream
    void on_vkQueueHostSyncGOOGLE(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                  uint32_t needHostSync, uint32_t sequenceNumber);
    void on_vkQueueSubmitAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                     VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                     uint32_t submitCount, const VkSubmitInfo* pSubmits,
                                     VkFence fence);
    void on_vkQueueSubmitAsync2GOOGLE(gfxstream::base::BumpPool* pool,
                                      VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                      uint32_t submitCount, const VkSubmitInfo2* pSubmits,
                                      VkFence fence);
    void on_vkQueueWaitIdleAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue);
    void on_vkQueueBindSparseAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                         uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                         VkFence fence);

    // VK_GOOGLE_gfxstream
    void on_vkGetLinearImageLayoutGOOGLE(gfxstream::base::BumpPool* pool,
                                         VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                         VkFormat format, VkDeviceSize* pOffset,
                                         VkDeviceSize* pRowPitchAlignment);
    void on_vkGetLinearImageLayout2GOOGLE(gfxstream::base::BumpPool* pool,
                                          VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                          const VkImageCreateInfo* pCreateInfo,
                                          VkDeviceSize* pOffset, VkDeviceSize* pRowPitchAlignment);

    // VK_GOOGLE_gfxstream
    void on_vkQueueFlushCommandsGOOGLE(gfxstream::base::BumpPool* pool,
                                       VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                       VkCommandBuffer commandBuffer, VkDeviceSize dataSize,
                                       const void* pData, const VkDecoderContext& context);
    void on_vkQueueFlushCommandsFromAuxMemoryGOOGLE(gfxstream::base::BumpPool* pool,
                                                    VkSnapshotApiCallInfo* snapshotInfo,
                                                    VkQueue queue, VkCommandBuffer commandBuffer,
                                                    VkDeviceMemory deviceMemory,
                                                    VkDeviceSize dataOffset, VkDeviceSize dataSize,
                                                    const VkDecoderContext& context);
    void on_vkQueueCommitDescriptorSetUpdatesGOOGLE(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
        uint32_t descriptorPoolCount, const VkDescriptorPool* pDescriptorPools,
        uint32_t descriptorSetCount, const VkDescriptorSetLayout* pDescriptorSetLayouts,
        const uint64_t* pDescriptorSetPoolIds, const uint32_t* pDescriptorSetWhichPool,
        const uint32_t* pDescriptorSetPendingAllocation,
        const uint32_t* pDescriptorWriteStartingIndices, uint32_t pendingDescriptorWriteCount,
        const VkWriteDescriptorSet* pPendingDescriptorWrites);
    void on_vkCollectDescriptorPoolIdsGOOGLE(gfxstream::base::BumpPool* pool,
                                             VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                             VkDescriptorPool descriptorPool,
                                             uint32_t* pPoolIdCount, uint64_t* pPoolIds);
    VkResult on_vkQueueBindSparse(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                  uint32_t bindInfoCount, const VkBindSparseInfo* pBindInfo,
                                  VkFence fence);
    void on_vkQueueSignalReleaseImageANDROIDAsyncGOOGLE(gfxstream::base::BumpPool* pool,
                                                        VkSnapshotApiCallInfo* snapshotInfo,
                                                        VkQueue queue, uint32_t waitSemaphoreCount,
                                                        const VkSemaphore* pWaitSemaphores,
                                                        VkImage image);
    VkResult on_vkQueuePresentKHR(gfxstream::base::BumpPool* pool,
                                  VkSnapshotApiCallInfo* snapshotInfo, VkQueue queue,
                                  const VkPresentInfoKHR* pPresentInfo);

    VkResult on_vkCreateSamplerYcbcrConversion(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
    VkResult on_vkCreateSamplerYcbcrConversionKHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
        const VkSamplerYcbcrConversionCreateInfo* pCreateInfo,
        const VkAllocationCallbacks* pAllocator, VkSamplerYcbcrConversion* pYcbcrConversion);
    void on_vkDestroySamplerYcbcrConversion(gfxstream::base::BumpPool* pool,
                                            VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                            VkSamplerYcbcrConversion ycbcrConversion,
                                            const VkAllocationCallbacks* pAllocator);
    void on_vkDestroySamplerYcbcrConversionKHR(gfxstream::base::BumpPool* pool,
                                               VkSnapshotApiCallInfo* snapshotInfo, VkDevice device,
                                               VkSamplerYcbcrConversion ycbcrConversion,
                                               const VkAllocationCallbacks* pAllocator);

    VkResult on_vkEnumeratePhysicalDeviceGroups(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
        uint32_t* pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);
    VkResult on_vkEnumeratePhysicalDeviceGroupsKHR(
        gfxstream::base::BumpPool* pool, VkSnapshotApiCallInfo* snapshotInfo, VkInstance instance,
        uint32_t* pPhysicalDeviceGroupCount,
        VkPhysicalDeviceGroupProperties* pPhysicalDeviceGroupProperties);

    void on_DeviceLost();

    void on_CheckOutOfMemory(VkResult result, uint32_t opCode, const VkDecoderContext& context,
                             std::optional<uint64_t> allocationSize = std::nullopt);

    // Fence waits
    VkResult waitForFence(VkFence boxed_fence, uint64_t timeout);

    // Wait for present (vkQueueSignalReleaseImageANDROID). This explicitly
    // requires the image to be presented again versus how many times it's been
    // presented so far, so it ends up incrementing a "target present count"
    // for this image, and then waiting for the image to get vkQSRI'ed at least
    // that many times.
    AsyncResult registerQsriCallback(VkImage boxed_image, VkQsriTimeline::Callback callback);

    // Transformations
    void deviceMemoryTransform_tohost(VkDeviceMemory* memory, uint32_t memoryCount,
                                      VkDeviceSize* offset, uint32_t offsetCount,
                                      VkDeviceSize* size, uint32_t sizeCount, uint32_t* typeIndex,
                                      uint32_t typeIndexCount, uint32_t* typeBits,
                                      uint32_t typeBitsCount);
    void deviceMemoryTransform_fromhost(VkDeviceMemory* memory, uint32_t memoryCount,
                                        VkDeviceSize* offset, uint32_t offsetCount,
                                        VkDeviceSize* size, uint32_t sizeCount, uint32_t* typeIndex,
                                        uint32_t typeIndexCount, uint32_t* typeBits,
                                        uint32_t typeBitsCount);

    // Snapshot access
    VkDecoderSnapshot* snapshot();

    // get a generic handle, this handle
    // currently is used to represent some
    // action related api call, such as
    // vkUpdateDescriptorSets, vkBeginCommandBuffer,
    // vkCmd***
    // this generic handle differs from other
    // cration handles (such as vkAllocate***,
    // vkCreate***); but important for snapshoter
    // to use this generic handle to represent some
    // actions and their dependency. with this,
    // the action apis will naturally fit into
    // the dependency graph to ensure correct
    // ordering of api calls during snapshot save and during
    // snapshot load; this will deprecate the current
    // approach of appending "modifying api's"
    // near the end of snapshot save and loading; the reason
    // to deprecate the modifying api approach is that it
    // cannot handle dependencies properly.
    uint64_t newGlobalVkGenericHandle(BoxedHandleTypeTag typeTag = Tag_VkGeneric);

#define DEFINE_TRANSFORMED_TYPE_PROTOTYPE(type)                \
    void transformImpl_##type##_tohost(const type*, uint32_t); \
    void transformImpl_##type##_fromhost(const type*, uint32_t);

    LIST_TRANSFORMED_TYPES(DEFINE_TRANSFORMED_TYPE_PROTOTYPE)

   private:
    class Impl;
    std::unique_ptr<Impl> mImpl;
};

}  // namespace vk
}  // namespace gfxstream
