#version 450 core

#extension GL_GOOGLE_include_directive : require

#extension GL_KHR_shader_subgroup_clustered : enable
#extension GL_KHR_shader_subgroup_shuffle : enable

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
layout(binding = 0, rgba32ui) readonly uniform uimage2DArray srcImage;
layout(binding = 1, rgba32ui) writeonly uniform uimage2DArray dstImage;

layout(push_constant) uniform imagInfo {
    uvec2 blockSize;
    uint baseLayer;
    uint smallBlock;  // TODO(gregschlom) Remove this once we remove the old decoder.
}
u_pushConstant;

#include "AstcDecompressor.glsl"

// Decodes an ASTC-encoded pixel at `texelPos` to RGBA
uvec4 decodeRGBA(uvec2 texelPos, uint layer) {
    uvec2 blockPos = texelPos / u_pushConstant.blockSize;
    uvec2 posInBlock = texelPos % u_pushConstant.blockSize;

    astcBlock = imageLoad(srcImage, ivec3(blockPos, layer)).wzyx;
    astcDecoderInitialize(astcBlock, u_pushConstant.blockSize);
    return astcDecodeTexel(posInBlock);
}

ivec2 build_coord() {
    uvec2 base = (gl_WorkGroupID.xy) * 8;
    uint blockid = gl_LocalInvocationID.x >> 4u;
    uint blockxy = gl_LocalInvocationID.x & 0xfu;
    base.x += 4 * (blockid & 0x1);
    base.y += 2 * (blockid & 0x2);
    base += uvec2(blockxy & 0x3, blockxy >> 0x2);
    return ivec2(base);
}

uint flip_endian(uint v) {
    uvec4 words = uvec4(v) >> uvec4(0, 8, 16, 24);
    words &= 0xffu;
    return (words.x << 24u) | (words.y << 16u) | (words.z << 8u) | (words.w << 0u);
}

uvec2 flip_endian(uvec2 v) { return uvec2(flip_endian(v.y), flip_endian(v.x)); }

uint GetIndicesRGB(vec3 color, vec3 minColor, vec3 maxColor, int scale) {
    vec3 dir = maxColor - minColor;
    float distMin = dot(minColor, dir);
    float distMax = dot(maxColor, dir);
    float dist = dot(color, dir);
    uint ind = uint(clamp(int((dist - distMin) / (distMax - distMin) * scale + 0.5f), 0, scale));

    // BC1 index mapping
    //  color0: maxColor
    //  color1: minColor
    //  color2: (2/3)*maxColor + (1/3)*minColor
    //  color3: (1/3)*maxColor + (2/3)*minColor
    // The mapping is:
    //  0 -> 1
    //  1 -> 3
    //  2 -> 2
    //  3 -> 0
    // Tranparent case
    //  color0: minColor
    //  color1: maxColor
    //  color2: (1/2)*maxColor + (1/2)*minColor
    //  color3: 0
    // The mapping is:
    //  0 -> 0
    //  1 -> 2
    //  2 -> 1
    ind = -ind & 3;
    ind ^= uint(ind < 2);
    ind += scale;
    ind -= 3;
    return ind;
}

// Select end point using PCA
void ComputeMaxMinColor(uvec3 rgbColor, inout uvec3 minColor, inout uvec3 maxColor) {
    ivec3 dx;
    dx = ivec3(rgbColor) - ivec3((subgroupClusteredAdd(rgbColor, 16) + 8) >> 4);

    float cov0 = float(subgroupClusteredAdd(dx.r * dx.r, 16));
    float cov1 = float(subgroupClusteredAdd(dx.r * dx.g, 16));
    float cov2 = float(subgroupClusteredAdd(dx.r * dx.b, 16));
    float cov3 = float(subgroupClusteredAdd(dx.g * dx.g, 16));
    float cov4 = float(subgroupClusteredAdd(dx.g * dx.b, 16));
    float cov5 = float(subgroupClusteredAdd(dx.b * dx.b, 16));

    vec3 vg = vec3(subgroupClusteredMax(rgbColor, 16) - subgroupClusteredMin(rgbColor, 16));
    float eigenvalue = 0.0f;

    // unroll ? compiler should do
    for (int i = 0; i < 4; i++) {
        float r = dot(vec3(cov0, cov1, cov2), vg);
        float g = dot(vec3(cov1, cov3, cov4), vg);
        float b = dot(vec3(cov2, cov4, cov5), vg);
        vg = vec3(r, g, b);
        eigenvalue = sqrt(dot(vg, vg));
        if (eigenvalue > 0.0f) {
            float invNorm = 1.0f / eigenvalue;
            vg *= invNorm;
        }
    }

    const float kDefaultLuminanceThreshold = 4.0f * 255;
    const float kQuantizeRange = 0.512f;

    if (eigenvalue < kDefaultLuminanceThreshold) {
        vg = vec3(0.299f, 0.587f, 0.114f);
    } else {
        float magn = max(max(abs(vg.r), abs(vg.g)), abs(vg.b));
        vg *= kQuantizeRange / magn;
    }
    float dist = dot(vec3(rgbColor), vg);
    float min_dist = subgroupClusteredMin(dist, 16);
    float max_dist = subgroupClusteredMax(dist, 16);
    uint min_index = subgroupClusteredMax(dist == min_dist ? gl_SubgroupInvocationID : 0, 16);
    uint max_index = subgroupClusteredMax(dist == max_dist ? gl_SubgroupInvocationID : 0, 16);
    minColor = subgroupShuffle(rgbColor, min_index);
    maxColor = subgroupShuffle(rgbColor, max_index);
}

uint GetIndicesAlpha(int alpha, int minAlpha, int maxAlpha) {
    float dist = float(maxAlpha - minAlpha);
    uint ind = uint(float(alpha - minAlpha) / dist * 7.0f + 0.5f);
    // 0 : maxAlpha
    // 1 : minAlpha
    // 2 : 6/7*maxAlpha + 1/7*minAlpha;
    // 3 : 5/7*maxAlpha + 2/7*minAlpha;
    // 4 : 4/7*maxAlpha + 3/7*minAlpha;
    // 5 : 3/7*maxAlpha + 4/7*minAlpha;
    // 6 : 2/7*maxAlpha + 5/7*minAlpha;
    // 7 : 1/7*maxAlpha + 6/7*minAlpha;
    // so the mapping is
    // 0 -> 1
    // 7 -> 0
    // 1 -> 7
    // 2 -> 6
    // 3 -> 5
    // 4 -> 4
    // 5 -> 3
    // 6 -> 2

    ind = -ind & 7;
    ind ^= int(2 > ind);
    return ind;
}

void ComputeMaxMin(int alpha, inout int minAlpha, inout int maxAlpha) {
    minAlpha = subgroupClusteredMin(alpha, 16);
    maxAlpha = subgroupClusteredMax(alpha, 16);
}

uvec2 EncodeBC4(int value, uint pid) {
    int minValue, maxValue;
    ComputeMaxMin(value, minValue, maxValue);
    uint indices = 0;
    if (minValue != maxValue) {
        indices = GetIndicesAlpha(value, minValue, maxValue);
    }
    uint indices0 = pid < 5 ? indices << (3 * pid + 16) : 0x0;
    uint indices1 = pid > 5 ? indices << (3 * pid - 16) : 0x0;
    if (pid == 5) {
        indices0 |= (indices & 0x1) << 31;
        indices1 |= (indices & 0x6) >> 1;
    }
    uint mask0 = subgroupClusteredOr(indices0, 16);
    uint mask1 = subgroupClusteredOr(indices1, 16);

    return uvec2((maxValue & 0xff) | ((minValue & 0xff) << 8) | mask0, mask1);
}

uint packColorToRGB565(uvec3 color) {
    return ((color.r >> 3) << 11) | ((color.g >> 2) << 5) | (color.b >> 3);
}

void swap(inout uint a, inout uint b) {
    uint t = a;
    a = b;
    b = t;
}

void main() {
    ivec2 coord = build_coord();
    ivec2 pixel_coord = coord & 3;
    int linear_pixel = 4 * pixel_coord.x + pixel_coord.y;
    int pid = 4 * pixel_coord.y + pixel_coord.x;

    ivec4 result = ivec4(decodeRGBA(coord, 0));
    uvec4 finalResult;

    uvec3 minColor, maxColor;
    uint indices = 0;
    uint color565 = 0;

    ComputeMaxMinColor(uvec3(result.r, result.g, result.b), minColor, maxColor);

    uint minColor565 = packColorToRGB565(minColor);
    uint maxColor565 = packColorToRGB565(maxColor);

    if (minColor565 != maxColor565) {
        indices =
            GetIndicesRGB(vec3(result.r, result.g, result.b), vec3(minColor), vec3(maxColor), 3);
    }
    bool flip = maxColor565 < minColor565;
    if (flip) {
        indices ^= 1;
        swap(maxColor565, minColor565);
    }
    color565 = maxColor565 | (minColor565 << 16);

    uint mask = subgroupClusteredOr(indices << (2 * pid), 16);
    finalResult.b = color565;
    finalResult.a = mask;
    finalResult.rg = EncodeBC4(result.a, pid);

    if (pid == 0) {
        imageStore(dstImage, ivec3(coord / 4, 0), finalResult);
    }
}
